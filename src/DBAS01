;                        FILE 1      declarations and startup > DBAS01
 ORG &8000
 CPU 1 ; this version solely for CMOS 6502

REPPTR * &00FD
LOMEM * &0000
FSA * LOMEM+2
AESTKP * FSA+2
HIMEM * AESTKP+2
LOLINO * HIMEM+2
CURSOR * LOLINO+2
LINE * CURSOR+1
SEED * LINE+2
TOP * SEED+5
PRINTS * TOP+2
PRINTF * PRINTS+1
OSCLI * &FFF7
OSWRCH * &FFEE
OSASCI * &FFE3
OSCRLF * &FFE7
OSRDCH * &FFE0
OSFILE * &FFDD
OSARGS * &FFDA
OSBGET * &FFD7
OSBPUT * OSBGET-3
OSFIND * OSBPUT-6
OSBYTE * &FFF4
OSWORD * &FFF1
ERRORH * PRINTF+1
TXTP * ERRORH+2
AELINE * TXTP+1
AECUR * AELINE+2
DATAP * AECUR+1
TALLY * DATAP+2
LISTOP * TALLY+1
TRFLAG * LISTOP+1
TRNUM * TRFLAG+1
WIDTHV * TRNUM+2
DOSTKP * WIDTHV+1
SUBSTP * DOSTKP+1
FORSTP * SUBSTP+1
TYPE * FORSTP+1
BYTESM * TYPE+1
OPCODE * BYTESM+1
IACCL * OPCODE+1
IACCM * IACCL+1
IACCN * IACCL+2
IACCH * IACCL+3
FACCS * IACCL+4
FACCXH * FACCS+1
FACCX * FACCXH+1
FACCMA * FACCX+1
FACCMB * FACCMA+1
FACCMC * FACCMB+1
FACCMD * FACCMC+1
FACCMG * FACCMD+1
CLEN * FACCMG+1
WORK * CLEN+1
MODE * WORK+4
CONSTA * MODE+1
FWRKS * WORK+4
FWRKX * FWRKS+1
FWRKMA * FWRKX+1
FWRKMB * FWRKMA+1
FWRKMC * FWRKMB+1
FWRKMD * FWRKMC+1
FWRKMG * FWRKMD+1
FTMPMA * FWRKMG+1
FTMPMB * FTMPMA+1
FTMPMC * FTMPMB+1
FTMPMD * FTMPMC+1
FTMPMG * FTMPMD+1
FRDDDP * FTMPMG+1
FRDDDX * FRDDDP+1
FPRTDX * FRDDDX
FRDDW * FRDDDX+1
FQUAD * FRDDW
ARGP * FQUAD+1
FPRTWY * ARGP+2
FPRTWN * FPRTWY+1
FDIGS * FPRTWN
COEFP * ARGP+2
NEWVAR * COEFP+2
VARL * &0400
PC * VARL+&40
FWSA * VARL+&6C
FWSB * FWSA+5
FWSC * FWSB+5
FWSD * FWSC+5
VARPTR * &0480
DOADL * &0500
DOADH * DOADL+&14
FORINL * DOADH+&14
FORINH * FORINL+1
FORINT * FORINH+1
FORSPL * FORINT+1
FORSPM * FORSPL+1
FORSPN * FORSPM+1
FORSPH * FORSPN+1
FORSPE * FORSPH+1
FORLML * FORSPE+1
FORLMM * FORLML+1
FORLMN * FORLMM+1
FORLMH * FORLMN+1
FORLME * FORLMH+1
FORADL * FORLME+1
FORADH * FORADL+1
SUBADL * FORADH+&96
SUBADH * SUBADL+&1A
STRACC * &0600
BUFFER * &0700
FORTOP * &96
SUBTOP * &1A
DOTOP * &14
BB CMPIM 1
 BEQ ENTRY
 RTS
 NOP
 = &60 ;defn
 = COPYR
 = &04 ;ver
 = "BASIC"

COPYR = 0
 = "(C)1985 Acorn",10,13
 = 0
 & BB
VALM = &00
 = &00;next two zeroes!
 = &00
 = &03
 = &27
VALL = &01 ;table of numeric values
 = &0A
 = &64
 = &E8
 = &10
ENTRY AND SEED+4 ;A was 1 so test bottom bit
 ORA SEED
 ORA SEED+1
 ORA SEED+2
 ORA SEED+3
 BNE RNDOK
 LDAIM "A"
 STA SEED
 EORIM "R" :EOR: "A"
 STA SEED+1
 EORIM "W" :EOR: "R"
 STA SEED+2
RNDOK LDAIM &84
 JSR OSBYTE
 STX HIMEM
 STY HIMEM+1
 DEA ;A=&83 now
 JSR OSBYTE
 STY TXTP
 CLR LISTOP
 CLR VARL+2
 CLR VARL+3
 LDXIM &FF
 STX WIDTHV
 LDXIM 10
 STX VARL
 DEX
 STX VARL+1
 LDAIM BREK
 STA &202
 LDAIM /BREK
 STA &203
 CLI
 JMP ENTRYY
LOOKFN STY WORK+2
 LDYIM 1
 LDAIY WORK
 LDYIM &F6
 CMPIM TPROC
 BEQ LOOKMN
 LDYIM &F8
 BRA LOOKMN
;  LOOKUP is given a base address-1 in WORK,WORK+1 length+1 in Y
;  It returns with EQ set if it can't find the thing, else with
;  IACCL,IACCM pointing to the data item and NEQ.
;  Note that the data is stored ADDRL,ADDRH,"R","E","D",0
LOOKUP STY WORK+2
 LDYIM 1
 LDAIY WORK
 ASLA
 TAY
LOOKMN LDAAY VARPTR-&7F
 BEQ LOOKFX
 STA IACCM
 LDAAY VARPTR-&80
 BRA LOOPLC
LOOPLB LDYIM 1
 LDAIY IACCL
 BEQ LOOKFX
 TAY
 LDAI IACCL
 STY IACCM
LOOPLC STA IACCL
 LDYIM 2
 LDAIY IACCL
 BNE LOOPSA
 CPY WORK+2
 BNE LOOPLB
 BRA LOOPTA
LOOPRA LDAIY IACCL
 BEQ LOOPLB
LOOPSA CMPIY WORK
 BNE LOOPLB
 INY
 CPY WORK+2
 BNE LOOPRA
 LDAIY IACCL
 BNE LOOPLB
LOOPTA TYA
 ADC IACCL
 STA IACCL
 BCC LOOKFX ;NEQ if taken because adding Y and C=1
 INC IACCM ;this is what sets NEQ (!)
LOOKFX RTS
FNDLNO CLR WORK+6 ;find line number in iacc
 LDA TXTP
 STA WORK+7
SIGHT LDYIM 1
 LDAIY WORK+6
 CMP IACCM
 BCS LOOK
LOOKR LDYIM 3
 LDAIY WORK+6
 ADC WORK+6
 STA WORK+6
 BCC SIGHT
 INC WORK+7
 BRA SIGHT
LOOK BNE PAST
 INY ;Y was 1
 LDAIY WORK+6
 CMP IACCL
 BCC LOOKR
 ASSERT :MSB: SIGHT = :MSB: .
 BNE PAST
 RTS ; carry set if found
PAST LDYIM 2
 CLC
 RTS
DIVOP JSR INTEGY ;divide with remainder
 LDA IACCH
 PHA
 JSR ABSCOM
 JSR PHPOW
 STX TYPE
 JSR INTEGY
 PLA
 STA WORK+1
 EOR IACCH
 STA WORK
 JSR ABSCOM
 LDXIM WORK+2
 JSR POPX
 LDXIM 3
 LDYIM 3
 LDAIM 0
DIVCLR CLRAX WORK+6
 ORAAX IACCL
 BNE .+3
 DEY
 DEX
 BPL DIVCLR
 TYA
 BMI ZDIVOR
 LDXAY IACCL
 BPL .+5
 INY ;allow for overflow into next byte
 CLR IACCH+1 ;allow for highest divisor
 STY WORK+11
 TAY
 LDXIM 3
DIVJUS LDAAX WORK+2
 BNE DIVFWD
 DEX
 BPL DIVJUS
 RTS
DIVFWD CMPAY IACCL
 BCS DIVER-3
DIVBCK LDAAX WORK+2
 STAAY WORK+6 ;moves bytes into remainder which are lower
 CLRAX WORK+2 ;than leading byte of divisor
 DEX
 BMI DIVFWD-1 ;Dividend<Divisor
 DEY
 BPL DIVBCK
DIVER LDYIM 8
 STX WORK+10
DIVER2 ROLAX WORK+2
 ROL WORK+6
 ROL WORK+7
 ROL WORK+8
 ROL WORK+9
 LDX WORK+11
 LDAAX WORK+6
 CMPAX IACCL
 BNE .+5
 DEX
 BPL .-7
 BCC NOSUB
 LDA WORK+6
 SBC IACCL
 STA WORK+6
 LDX WORK+11
 BEQ NOSUB
 LDA WORK+7
 SBC IACCM
 STA WORK+7
 DEX
 BEQ NOSUB
 LDA WORK+8
 SBC IACCN
 STA WORK+8
 LDA WORK+9
 SBC IACCH
 STA WORK+9
NOSUB LDX WORK+10
 DEY
 BNE DIVER2
 ROLAX WORK+2
 DEX
 BPL DIVER
 ASSERT :MSB: DIVER = :MSB: .
 RTS
ZDIVOR BRK
 = &12
 = "Division by zero"
 BRK
FWPPFL JSR POPACC
 JSR FTOW ;extra entry
IFLT CLR FACCMG
 LDA IACCH
 STA FACCS
 BPL IFLTA
 JSR COMPNO
 LDA IACCH
IFLTA BNE IFLTAC
 CLR FACCMD
 LDY IACCL
 LDA IACCN
 BNE IFLTAD
 CLR FACCMC
 LDA IACCM
 BEQ IFLTAH
 STY FACCMB
 LDYIM &90
IFLTAK ORAIM 0
 BMI FNRMX2
FNRMB2 DEY
 ASL FACCMD
 ROL FACCMC
 ROL FACCMB
 ROLA
 BPL FNRMB2
 ASSERT :MSB: FNRMB2 = :MSB: .
 BRA FNRMX2
IFLTAD STY FACCMC
 LDY IACCM
 STY FACCMB
 LDYIM &98
 BRA IFLTAK
IFLTAC LDY IACCN
 STY FACCMB
 LDY IACCM
 STY FACCMC
 LDY IACCL
 STY FACCMD
 LDYIM &A0
 BRA IFLTAK
IFLTAH CLR FACCMB
 TYA
 BNE FLTAA 
FTSTZ CLR FACCMA
 CLR FACCS
 CLR FACCX
 CLR FACCXH ;STANDARD STATE ZERO
 RTS
;   FLTACC FLOATS 8 BIT ACC
FLTACC STA FACCS ;SET SIGN IN ACC
 JSR FCLR+6
 LDA FACCS
 BEQ FTSTZ
 BPL FLTAA ;>=0
 EORIM &FF
 INA
FLTAA LDYIM &89
 LSRA
 DEY
 ROLA
 BPL .-2
FNRMX2 STY FACCX
 CLR FACCXH
 STA FACCMA
FNRMX RTS
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
;   FNRM normalizes FACC using 16 bit exponent, so
;   no worry about exponent overflow
;   leading byte in A, not necessarily in FACCMA
FNRM2 BMI FNRMB ;+2 also entry point
 BNE FNRMAZ
 ORA FACCMB
 ORA FACCMC
 ORA FACCMD
 ORA FACCMG
 BEQ FTSTZ
 LDY FACCX
FNRMA LDA FACCMB
 PHA
 LDA FACCMC
 STA FACCMB
 LDA FACCMD
 STA FACCMC
 LDA FACCMG
 STA FACCMD
 CLR FACCMG ;MOVED BY A BYTE
 TYA
 SEC
 SBCIM &08
 TAY
 PLA
 BEQ FNRMA ;TRY AGAIN
 ASSERT :MSB: FNRMA = :MSB: .
 BRA FNRMXA-2
FNRMAZ LDY FACCX
FNRMC DEY
 ASL FACCMG
 ROL FACCMD
 ROL FACCMC
 ROL FACCMB
 ROLA
 BPL FNRMC ;if -ve,then fully normalized
 ASSERT :MSB: FNRMC = :MSB: .
FNRMXA CPY FACCX ;new exp. must be < old exp
 STY FACCX
 BCC .+4
 DEC FACCXH
 TAY ;to ensure that - flag is set
FNRMB STA FACCMA
 RTS
; SFIX right-justifies INTEGER part of FACC.to 4 bytes
; FFIX also indicates,in FWRKMA, presence of a fractional part (0 or <>0)
FFIX CLR FWRKMA
 LDY FACCMA
 BRA .+6
SFIX LDY FACCMA
 STY FWRKMA
 LDA FACCX
 CMPIM &81
 BCS SFIXA
 STY FWRKMA ;<1.0
 JMP FCLR
SFIXA CMPIM &A0
 BCC SFIXQ
FFIXV JMP FOVR ;overflow
SFIXG LSR FACCMA
 ROR FACCMB
 ROR FACCMC
 ROR FACCMD
 BCC SFIXQ-1 ;irrelevant for SFIX
 STA FWRKMA
 INA
SFIXQ BITIM 7
 BNE SFIXG
 ASSERT :MSB: SFIXG = :MSB: .
 ANDIM &18
 BEQ FFIXY ;done
 LSRA
 LSRA
 LSRA
 TAY
 PHX
 EORIM 3
 TAX
 LDA FWRKMA
 BNE SFIXSS ;fractional part definitely exists.
 CLR FACCMG ;this section always omitted in SFIX
 LDA FACCMD
 ORAAY FACCMA
 ORAAY FACCMB
 STA FWRKMA
SFIXSS LDA FACCMC
 STA FACCMD
 LDA FACCMB
 STAAX FACCMC
 LDA FACCMA
 STAAX FACCMB
 CLRAX FACCMA
 DEX
 BPL .-3
 PLX
 CLR FACCMG
FFIXY LDA FACCS
 BPL FFIXZ ;>=0.0 so done now
;   FINEG negates 32 bit integer in FACCMA-FACCMD
FINEG SEC
 LDYIM 0
 TYA
 SBC FACCMD
 STA FACCMD
 TYA
 SBC FACCMC
 STA FACCMC
 TYA
 SBC FACCMB
 STA FACCMB
 TYA
 SBC FACCMA
 STA FACCMA
FFIXZ RTS
FINC INC FACCMD
 BNE FNEARZ
 INC FACCMC
 BNE FNEARZ
 INC FACCMB
 BNE FNEARZ
 INC FACCMA
 BEQ FFIXV ;OVERFLOW
FNEARZ RTS
 LDA &400
 LDA &400
 LDA &400
 LDA &400
FRNDAB LDYIM 4
RTOP ROR SEED+4
 LDA SEED+3
 TAX
 RORA
 STA SEED+4
 LDA SEED+2
 STA SEED+3
 LSRA
 EOR SEED+1
 ANDIM &0F
 EOR SEED+1
 RORA
 RORA
 RORA
 RORA
 EOR SEED+4
 STX SEED+4
 LDX SEED+1
 STX SEED+2
 LDX SEED
 STX SEED+1
 STA SEED
 DEY
 BNE RTOP
 ASSERT :MSB: RTOP = :MSB: .
 RTS
FWTOA LDA FWRKS
 STA FACCS
 CLR FACCXH
 LDA FWRKX
 STA FACCX
FMWTOA LDA FWRKMB
 STA FACCMB
 LDA FWRKMC
 STA FACCMC
 LDA FWRKMD
 STA FACCMD
 LDA FWRKMG
 STA FACCMG
 LDA FWRKMA
 STA FACCMA
FADDZ RTS
FADDW1 LDA FACCMA ;SEE IF ADDING TO 0
 BEQ FWTOA ;LOAD WITH W
;   HERE I HAVE A NONTRIVIAL ADD
 SEC
 LDA FACCX
 SBC FWRKX
 BEQ FADDA
 BCC FADDB ;X(ACC)<X(WRK)
 CMPIM &25
 BCS FADDZ ;SHIFT TOO LARGE FOR SIGNIFICANCE
;   Now shift W right
 TAY
 ANDIM &38
 BEQ FADDCA
 SEC
FADDCB LDX FWRKMD
 STX FWRKMG
 LDX FWRKMC
 STX FWRKMD
 LDX FWRKMB
 STX FWRKMC
 LDX FWRKMA
 STX FWRKMB
 CLR FWRKMA
 SBCIM 8
 BNE FADDCB
FADDCA TYA
 ANDIM &07
 BEQ FADDA
FADDC LSR FWRKMA
 ROR FWRKMB
 ROR FWRKMC
 ROR FWRKMD
 ROR FWRKMG
 DEA
 BNE FADDC
 ASSERT :MSB: FADDC = :MSB: .
 BRA FADDA ;ALIGNED
FADDB EORIM &FF
 INA ;AMOUNT TO SHIFT ACC
 CMPIM &25
 BCS FWTOA ;ACC NOT SIGNIFICANT
 LDY FWRKX ;X(RESULT) FROM X(WRK)
 STY FACCX
;   Now shift ACC right
 TAY
 ANDIM &38
 BEQ FADDDA
 SEC
FADDDB LDX FACCMD
 STX FACCMG
 LDX FACCMC
 STX FACCMD
 LDX FACCMB
 STX FACCMC
 LDX FACCMA
 STX FACCMB
 CLR FACCMA
 SBCIM 8
 BNE FADDDB
FADDDA TYA
 ANDIM &07
 BEQ FADDA
FADDD LSR FACCMA
 ROR FACCMB
 ROR FACCMC
 ROR FACCMD
 ROR FACCMG
 DEA
 BNE FADDD
 ASSERT :MSB: FADDD = :MSB: .
;     DROP THROUGH TO FADDA
FADDA LDA FACCS
 EOR FWRKS
 BMI FADDE ;different signs
 CLC ;BOTH SAME SIGN
 JMP FPLWF
FADDE LDA FACCMA
 CMP FWRKMA
 BNE FADDF
 LDA FACCMB
 CMP FWRKMB
 BNE FADDF
 LDA FACCMC
 CMP FWRKMC
 BNE FADDF
 LDA FACCMD
 CMP FWRKMD
 BNE FADDF
 LDA FACCMG
 CMP FWRKMG
 BNE FADDF
 JMP FCLR  ;ACC=WRK IN DIFFERENCE CASE
FADDF BCS FADDG ;ABS ACC>ABS WRK
 LDA FWRKS
 STA FACCS
 SEC
 LDA FWRKMG
 SBC FACCMG
 STA FACCMG
 LDA FWRKMD
 SBC FACCMD
 STA FACCMD
 LDA FWRKMC
 SBC FACCMC
 STA FACCMC
 LDA FWRKMB
 SBC FACCMB
 STA FACCMB
 LDA FWRKMA
 SBC FACCMA
 JMP FNRM2 ;overflow impossible
FADDG LDA FACCMG ;carry set at FADDF
 SBC FWRKMG
 STA FACCMG
 LDA FACCMD
 SBC FWRKMD
 STA FACCMD
 LDA FACCMC
 SBC FWRKMC
 STA FACCMC
 LDA FACCMB
 SBC FWRKMB
 STA FACCMB
 LDA FACCMA
 SBC FWRKMA
 JMP FNRM2

;  lexical tokens and name table

;  The table contains lexical tokens and an action byte
;    6 - polymorphic
;    5 - give up completely
;    4 - constant/list of constants may follow
;    3 - while byte<>wordc skip
;    2 - transfer to l mode
;    1 - transfer to r mode
;    0 - ignore if next character is wordc

;  Every token is recognizable at the start of any word

TAND * &80 ;expression binary operators
TDIV * TAND+1
TEOR * TDIV+1
TMOD * TEOR+1
TOR * TMOD+1

TERROR * TOR+1  ;miscellaneous words
TLINE * TERROR+1
TOFF * TLINE+1
TSTEP * TOFF+1
TSPC * TSTEP+1
TTAB * TSPC+1
TELSE * TTAB+1
TTHEN * TELSE+1

TCONST * TTHEN+1   ;(8D)

TOPENU * TCONST+1
TPTR * TOPENU+1 ;polymorphics as functions
TPAGE * TPTR+1
TTIME * TPAGE+1
TLOMM * TTIME+1
THIMM * TLOMM+1

TABS * THIMM+1 ;expression class of unary operators
TACS * TABS+1
TADC * TACS+1
TASC * TADC+1
TASN * TASC+1
TATN * TASN+1
TBGET * TATN+1
TCOS * TBGET+1
TCOUNT * TCOS+1
TDEG * TCOUNT+1
TERL * TDEG+1
TERR * TERL+1
TEVAL * TERR+1
TEXP * TEVAL+1
TEXT * TEXP+1
TFALSE * TEXT+1
TFN * TFALSE+1
TGET * TFN+1
TINKEY * TGET+1
TINSTR * TINKEY+1
TINT * TINSTR+1
TLEN * TINT+1
TLN * TLEN+1
TLOG * TLN+1
TNOT * TLOG+1
TOPENI * TNOT+1
TOPENO * TOPENI+1
TPI * TOPENO+1
TPOINT * TPI+1
TPOS * TPOINT+1
TRAD * TPOS+1
TRND * TRAD+1
TSGN * TRND+1
TSIN * TSGN+1
TSQR * TSIN+1
TTAN * TSQR+1
TTO * TTAN+1
TTRUE * TTO+1
TUSR * TTRUE+1
TVAL * TUSR+1
TVPOS * TVAL+1
TCHRD * TVPOS+1  ;string expression class of unary operators
TGETD * TCHRD+1
TINKED * TGETD+1
TLEFTD * TINKED+1
TMIDD * TLEFTD+1
TRIGHTD * TMIDD+1
TSTRD * TRIGHTD+1
TSTRND * TSTRD+1
TEOF * TSTRND+1

TAUTO * TEOF+1 ;commands
TDELET * TAUTO+1
TLOAD * TDELET+1
TLIST * TLOAD+1
TNEW * TLIST+1
TOLD * TNEW+1
TRENUM * TOLD+1
TSAVE * TRENUM+1
TEDIT * TSAVE+1

TPTR2 * TEDIT+1 ;polymorphics again
TPAGE2 * TPTR2+1
TTIME2 * TPAGE2+1
TLOMM2 * TTIME2+1
THIMM2 * TLOMM2+1

TBEEP * THIMM2+1 ;statements
TBPUT * TBEEP+1
TCALL * TBPUT+1
TCHAIN * TCALL+1
TCLEAR * TCHAIN+1
TCLOSE * TCLEAR+1
TCLG * TCLOSE+1
TCLS * TCLG+1
TDATA * TCLS+1
TDEF * TDATA+1
TDIM * TDEF+1
TDRAW * TDIM+1
TEND * TDRAW+1
TENDPR * TEND+1
TENVEL * TENDPR+1
TFOR * TENVEL+1
TGOSUB * TFOR+1
TGOTO * TGOSUB+1
TGRAPH * TGOTO+1
TIF * TGRAPH+1
TINPUT * TIF+1
TLET * TINPUT+1
TLOCAL * TLET+1
TMODE * TLOCAL+1
TMOVE * TMODE+1
TNEXT * TMOVE+1
TON * TNEXT+1
TVDU * TON+1
TPLOT * TVDU+1
TPRINT * TPLOT+1
TPROC * TPRINT+1
TREAD * TPROC+1
TREM * TREAD+1
TREPEAT * TREM+1
TREPORT * TREPEAT+1
TRESTOR * TREPORT+1
TRETURN * TRESTOR+1
TRUN * TRETURN+1
TSTOP * TRUN+1
TTEXT * TSTOP+1
TTRACE * TTEXT+1
TUNTIL * TTRACE+1
TWIDTH * TUNTIL+1
TOSCL * TWIDTH+1 ;this must be <=&FF (!)

TOKENS = "AND"   ;this table MUST be alphabetic in first char
 = TAND,0
 = "ABS"
 = TABS,0
 = "ACS"
 = TACS,0
 = "ADVAL"
 = TADC,0
 = "ASC"
 = TASC,0
 = "ASN"
 = TASN,0
 = "ATN"
 = TATN,0
 = "AUTO"
 = TAUTO,&10
 = "BGET"
 = TBGET,1
 = "BPUT"
 = TBPUT,3
 = "COLOUR"
 = TTEXT,2
 = "CALL"
 = TCALL,2
 = "CHAIN"
 = TCHAIN,2
 = "CHR$"
 = TCHRD,0
 = "CLEAR"
 = TCLEAR,1
 = "CLOSE"
 = TCLOSE,3
 = "CLG"
 = TCLG,1
 = "CLS"
 = TCLS,1
 = "COS"
 = TCOS,0
 = "COUNT"
 = TCOUNT,1
 = "COLOR"  ;for the Yanks
 = TTEXT,2
 = "DATA"
 = TDATA,&20
 = "DEG"
 = TDEG,0
 = "DEF"
 = TDEF,0
 = "DELETE"
 = TDELET,&10
 = "DIV"
 = TDIV,0
 = "DIM"
 = TDIM,2
 = "DRAW"
 = TDRAW,2
 = "ENDPROC"
 = TENDPR,1
 = "END"
 = TEND,1
 = "ENVELOPE"
 = TENVEL,2
 = "ELSE"
 = TELSE,&14
 = "EVAL"
 = TEVAL,0
 = "ERL"
 = TERL,1
 = "ERROR"
 = TERROR,4
 = "EOF"
 = TEOF,1
 = "EOR"
 = TEOR,0
 = "ERR"
 = TERR,1
 = "EXP"
 = TEXP,0
 = "EXT"
 = TEXT,1
 = "EDIT"
 = TEDIT,&10
 = "FOR"
 = TFOR,2
 = "FALSE"
 = TFALSE,1
 = "FN"
 = TFN,8
 = "GOTO"
 = TGOTO,&12
 = "GET$"
 = TGETD,0
 = "GET"
 = TGET,0
 = "GOSUB"
 = TGOSUB,&12
 = "GCOL"
 = TGRAPH,2
 = "HIMEM"
 = THIMM,&43
 = "INPUT"
 = TINPUT,2
 = "IF"
 = TIF,2
 = "INKEY$"
 = TINKED,0
 = "INKEY"
 = TINKEY,0
 = "INT"
 = TINT,0
 = "INSTR("
 = TINSTR,0
 = "LIST"
 = TLiST,&10
 = "LINE"
 = TLINE,0
 = "LOAD"
 = TLOAD,2
 = "LOMEM"
 = TLOMM,&43
 = "LOCAL"
 = TLOCAL,2
 = "LEFT$("
 = TLEFTD,0
 = "LEN"
 = TLEN,0
 = "LET"
 = TLET,4
 = "LOG"
 = TLOG,0
 = "LN"
 = TLN,0
 = "MID$("
 = TMIDD,0
 = "MODE"
 = TMODE,2
 = "MOD"
 = TMOD,0
 = "MOVE"
 = TMOVE,2
 = "NEXT"
 = TNEXT,2
 = "NEW"
 = TNEW,1
 = "NOT"
 = TNOT,0
 = "OLD"
 = TOLD,1
 = "ON"
 = TON,2
 = "OFF"
 = TOFF,0
 = "OR"
 = TOR,0
 = "OPENIN"
 = TOPENU,0
 = "OPENOUT"
 = TOPENO,0
 = "OPENUP"
 = TOPENI,0
 = "OSCLI"
 = TOSCL,2
 = "PRINT"
 = TPRINT,2
 = "PAGE"
 = TPAGE,&43
 = "PTR"
 = TPTR,&43
 = "PI"
 = TPI,1
 = "PLOT"
 = TPLOT,2
 = "POINT("
 = TPOINT,0
 = "PROC"
 = TPROC,&0A
 = "POS"
 = TPOS,1
 = "RETURN"
 = TRETURN,1
 = "REPEAT"
 = TREPEAT,0
 = "REPORT"
 = TREPORT,1
 = "READ"
 = TREAD,2
 = "REM"
 = TREM,&20
 = "RUN"
 = TRUN,1
 = "RAD"
 = TRAD,0
 = "RESTORE"
 = TRESTORE,&12
 = "RIGHT$("
 = TRIGHTD,0
 = "RND"
 = TRND,1
 = "RENUMBER"
 = TRENUM,&10
 = "STEP"
 = TSTEP,0
 = "SAVE"
 = TSAVE,2
 = "SGN"
 = TSGN,0
 = "SIN"
 = TSIN,0
 = "SQR"
 = TSQR,0
 = "SPC"
 = TSPC,0
 = "STR$"
 = TSTRD,0
 = "STRING$("
 = TSTRND,0
 = "SOUND"
 = TBEEP,2
 = "STOP"
 = TSTOP,1
 = "TAN"
 = TTAN,0
 = "THEN"
 = TTHEN,&14
 = "TO"
 = TTO,0
 = "TAB("
 = TTAB,0
 = "TRACE"
 = TTRACE,&12
 = "TIME"
 = TTIME,&43
 = "TRUE"
 = TTRUE,1
 = "UNTIL"
 = TUNTIL,2
 = "USR"
 = TUSR,0
 = "VDU"
 = TVDU,2
 = "VAL"
 = TVAL,0
 = "VPOS"
 = TVPOS,1
 = "WIDTH"
 = TWIDTH,2
 = "PAGE"  ;dratted polymorphics again
 = TPAGE2,0
 = "PTR"
 = TPTR2,0
 = "TIME"
 = TTIME2,0
 = "LOMEM"
 = TLOMM2,0
 = "HIMEM"
 = THIMM2,0
 = "Missing "
 = &8D,0
 LNK DBAS02
