;   FILE 9  PLUS, MINUS,TIMES,DIV,transcendentals. > DBAS08
;   SIN, COS, EXP, LN,SQR, ATN
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
 LDA &400
FCFSTP CLC
 LDA COEFP
 ADCIM &05
 STA COEFP ;extra entry
SETCOF LDYIM /RPLN10
 STA ARGP
 STY ARGP+1
 RTS
ARGA LDAIM FWSA
ARGCOM LDYIM /FWSA
 BRA SETCOF+2
P1BYM1 JSR FNEG ;(1+A)/(1-A), A<<1
 JSR STARGA ;(1-A)/(1+A), other entry
 JSR XDBYP1
 INC FACCX
FXDEC JSR FNEG ;1-A
FINC1 CLR FWRKS ;1+A
 LDYIM &80 ;other entry
 STY FWRKMA
 INY
 STY FWRKX
 CLR FWRKMB
 CLR FWRKMC
 CLR FWRKMD
 CLR FWRKMG
 JMP FADDW
M1BYP1 JSR FXDEC ;(1-A)/(1+A), A near 1.0
 LDX FACCMA
 BEQ ARGA-1
 DEC FACCX
 JSR STARGA
 TXA
 EOR FACCS
 STA FACCS ;entry from TAN
XDBYP1 JSR FINC1 ;pointer to FWSA
 BRA FXDIV
;   FIPOW COMPUTES X**N WHERE X IS PASSED IN
;   FACC, N IS A ONE BYTE SIGNED INTEGER PASSED IN A
FIPOW LDXIM 0
 TAY
 BEQ FONE
 BPL FIPOWA ;+VE POWER
 DEA
 EORIM &FF ;2'S COMPLEMENT ACC
 PHA
 JSR FRECIP ;X=0 on return
 PLA
FIPOWA LSRA
 BEQ FIPOWY
 PHA
 BCC .+6
 INX
 JSR PHFACC
 JSR FSQURE
 BRA FIPOWA-1
FIPOWB JSR POPSET
 JSR FMUL
FIPOWY DEX
 BPL FIPOWB
 TXA
 RTS
FONE LDAIM &80
 STA FACCMA
 INA
 STA FACCX
 JMP FCLRB
FDIVZ JMP ZDIVOR
FRECIP LDAIM ONEP0 ;set 1.0
 JSR SETCOF
;(argp) divided by facc
FXDIV LDA FACCMA
 BEQ FDIVZ ;divide by zero
 JSR FLDW
 BNE FDIVA ;result is zero
 JMP FCLR
FDIVA LDA FWRKS
 EOR FACCS
 STA FACCS ;SIGN CORRECT
 SEC
 LDA FWRKX ;difference of exponents
 ADCIM &81
 ROL FACCXH
 SBC FACCX
 BCS FDIVB
 DEC FACCXH
FDIVB STA FACCX
 LDA FWRKMA
 CLC
 LDYIM 4
 STY FWRKX
FDIVN LDXIM 8
FDIVE BCS FDIVH
 CMP FACCMA
 BNE FDIVF
 LDY FWRKMB
 CPY FACCMB
 BNE FDIVF
 LDY FWRKMC
 CPY FACCMC
 BNE FDIVF
 LDY FWRKMD
 CPY FACCMD
FDIVF BCC FDIVG ;WON'T GO
FDIVH TAY ;WRK-ACC, C BIT ALREADY SET FOR SBC
 LDA FWRKMD
 SBC FACCMD
 STA FWRKMD
 LDA FWRKMC
 SBC FACCMC
 STA FWRKMC
 LDA FWRKMB
 SBC FACCMB
 STA FWRKMB
 TYA
 SBC FACCMA
 SEC
FDIVG ROL FWRKS
 ASL FWRKMD
 ROL FWRKMC
 ROL FWRKMB
 ROLA
 DEX
 BNE FDIVE
 LDX FWRKS
 PHX
 DEC FWRKX
 BNE FDIVN
 ASSERT :MSB: FDIVN = :MSB: .
 PLX
 RORA
 LSR FACCMA ;entry from SQR
 STX FACCMD
 LDXIM 3
FDIVBK CMP FACCMA
 BCC .+4
 SBC FACCMA ;C already set
 PHP
 ASLA
 DEX
 BNE FDIVBK
 PLP
 RORA
 PLP
 RORA
 PLP
 RORA
 STA FACCMG
 PLA
 STA FACCMC
 PLA
 STA FACCMB
 PLA
 STA FACCMA
NRMTDY BMI FTIDY
 JSR FNRMAZ ;FACCMA must be 01XXXXXX
 BRA FTIDY
FSQURS JSR STARGA
FSQURE JSR FTOW
 BEQ FCLR ;FX in A
 CLR FACCMD
 ASL FWRKMD
 BCC FMUL1+2
 INC FACCMC
 BNE FMUL1+2
 JSR FPLNFJ
 BRA FMUL1+2
FMUL LDA FACCMA
 BEQ FADDZ2 ;0.0 * something
 JSR FLDW ;get other arg
FMUL1 BEQ FCLR ;A*0.0
 JSR IFMUL
 BRA FTIDY
FOVR BRK
 = &14
 = "Too big"
 BRK
ACS JSR ASN
PISUB LDAIM HALFPI
 JSR SETCOF
FXSUB LDA FACCMA
 EOR FACCS
 STA FACCS
FADD JSR FLDW
 BEQ FADDZ2 ;A+0.0 = A
FADDW JSR FADDW1
FTIDY LDA FACCMG
 BPL FTRNDZ
 ASLA
 BNE FTRNDY
 ROLA ;A was=&80 and C was set, so A=1
 AND FACCMD
 BNE FTRNDZ
FTRNDY INC FACCMD
 BNE FTRNDZ
 JSR FPLNFI;carry set on call
FTRNDZ LDA FACCXH
 BEQ FTIDYZ
 BPL FOVR ;overflow
FCLR CLR FACCX
 CLR FACCMA
FCLRB CLR FACCS
 CLR FACCXH
 CLR FACCMB
 CLR FACCMC
 CLR FACCMD
FTIDYZ CLR FACCMG
FADDZ2 LDAIM &FF
 RTS
IFMUL CLC ;FWRK is set
 LDA FACCX
 ADC FWRKX ;add exponents
 ROL FACCXH;set lsb of FACCXH and clear carry
;  Subtract &80 bias from exponent, do not check over/underflow
;  yet in case, renormalisation fixes things
 SBCIM &7F ;carry subtracts extra 1
 STA FACCX
 BCS FMULC
 DEC FACCXH
;   copy ACC to TMP, clear ACC then i can do ACC:=WRK*TMP
;   as a fixed point operation.
FMULC LDA FACCS
 EOR FWRKS
 STA FACCS ;GET SIGN RIGHT
 PHX
 LDXIM -8
 LDYIM 4
FMULCA LDAAX FACCMA+8
 CLRAX FACCMA+8
 STAAY FTMPMA-1
 INX
 DEY
 BNE FMULCA
 CLR FWRKX
 CLR FWRKX-1
 CLR FWRKX-2
 BRA FMULG
; X already -4; Y=0; use as FACCMG
FMULD PHX
 LSR FWRKMA
 ROR FWRKMB
 ROR FWRKMC
 ROR FWRKMD
 ROR FWRKMG
FMULE ASLAX FTMPMA+4
 BCC FMULF
 CLC
 TYA
 ADCAX FWRKMG+1
 TAY
 LDA FACCMD
 ADCAX FWRKMD+1
 STA FACCMD
 LDA FACCMC
 ADCAX FWRKMC+1
 STA FACCMC
 LDA FACCMB
 ADCAX FWRKMB+1
 STA FACCMB
 LDA FACCMA
 ADCAX FWRKMA+1
 STA FACCMA
FMULF INX
 BMI FMULE
 PLX
FMULG LDAAX FTMPMA+4
 BNE FMULD
 INX
 BMI FMULG
 ASSERT :MSB: FMULD = :MSB: .
 PLX
 STY FACCMG
 LDA FACCMA
 BMI FADDZ2+2
 JMP FNRM2+2
;   FLOG SETS ACC := LOG(ACC) (BASE E). Works by
;   (A) Check for ACC <= 0.0
;   (B) Strip exponent to put ACC in range 1.0 - 2.0
;       and renormalize to .707 TO 1.414
;   (B2) extra care with smallest possible exponent
;   (C) express log by cont. fract.for 2*ATANH (T), where T=(X-1)/(X+1)
;   (D) Add result to EXPONENT * LOG(2.0)
;   N.B. Result cannot overflow.
LN JSR FLTFAC
FLOG LDA FACCMA
 EOR FACCS 
 BPL FLOGA ;LOG(0.0 or <0.0) ILLEGAL
 LDYIM &80
 LDX FACCX
 BEQ FLOGD
 LDA FACCMA
 CMPIM &B5
 BCS FLOGD
 DEX
 INY
FLOGD PHX
 STY FACCX
 JSR M1BYP1 ;-TANH (Y)
 LDA FACCX
 BEQ FLOGE
 CMPIM &6E
 BCC FLOGE-2
 CLC
 JSR FCFATN
 INC FACCX
FLOGE JSR STARGA ;SAVE -LOG(X)
 PLA ;RECOVER EXPONENT BYTE
 EORIM &80
 BEQ FSQRTZ
 JSR FLTACC ;FLOAT 8 BIT ACC
 LDAIM LOGTWO
 JSR SETCOF
 JSR FMULHP ;multiply by LN2 to high precision
 JSR FTIDY ;FWSA has been Xsubtracted
FSQRTZ JMP FNEG
FLOGA BRK ;-VE OR ZERO LOG
 = &16
 = "Log range"
FSQRTN BRK
 = &15
 = "-ve root"
 = 0,&86,&8E ;tags for FRANGE
SQR JSR FLTFAC
FSQRT LDA FACCMA
 BEQ FSQRTZ ;SQRT(0.0) EASY
 LDA FACCS
 BMI FSQRTN ;bad -ve
 LDA FACCX
 LSRA
 PHP
 ADCIM &41
 STA FACCX
 LDA FACCMA
 PLP
 BCC FSQRTA
 LSRA
 ROR FACCMB
 ROR FACCMC
 ROR FACCMD
 ROR FACCMG
FSQRTA CLR FWRKMB
 CLR FWRKMC
 LDXIM &68
 SEC
 SBCIM &90
 BCS .+6 ;root starts with &60 or &40
 ADCIM &50
 LDXIM &48
 STA FACCMA
 TXA
 LDXIM -4
 LDYIM &C
FSQRTB STAAX FWRKMA+4
 ASL FACCMC ;MD & MG shifted separately
 ROL FACCMB
 ROL FACCMA
 LDA FACCMA ;only 3 bytes need be tested
;by the time FWRKMD/G are >0, they can no longer affect the result
 CMP FWRKMA
 BNE FSQRTP
 LDA FACCMB
 CMP FWRKMB
 BNE FSQRTP
 LDA FACCMC
 CMP FWRKMC
FSQRTP BCC FSQRTD
 LDA FACCMC
 SBC FWRKMC
 STA FACCMC
 LDA FACCMB
 SBC FWRKMB
 STA FACCMB
 LDA FACCMA
 SBC FWRKMA
 STA FACCMA
 TYA
 CLC
 ADCAX FWRKMA+4
 BCC FSQRTE
 INCAX FWRKMA+3
 BRA FSQRTE
FSQRTD TYA
 EORAX FWRKMA+4
FSQRTE STAAX FWRKMA+4
 TYA
 LSRA
 TAY
 BNE FSQRTB+2
 LDYZX FWRKMA+3
 PHY
 CPXIM -3
 BNE .+6
 LDA FACCMD
 STA FACCMC
 BCS FSQRTS
 PLY
 LDYIM 4 ;first time round
 ASL FACCMG
 ROL FACCMD
 ROLA ;A originally =0
 DEY
 BNE .-6
 TSB FACCMC
FSQRTS LDAIM &80
 LDYIM &C0
 INX
 BNE FSQRTB
 LDX FWRKMA
 LDA FACCMA
 STX FACCMA
 LDX FWRKMD
 ASLA
 CMP FACCMA
 BCC .+5
 SBC FACCMA
 INX
 JMP FDIVBK-6
; CONTIN.FRACTS. to calculate TAN(A) and ATN(A) in the form
; F(A)=A+ A*a1/(U+b1+ a2/(U+b2+ a3/(U+b3 +...)))
; where U=1/A^2 for hyperb. and U=-1/A^2 for trig.
; for ATANH:a1=1/3; a(n)= -((2n-2)*(2n-1)/(4n-3))^2 /(4n-5)/(4n-1)
;   b(n)= -( 1+ 1/(4n-3)/(4n+1) ) /2
; but a3 & b3 modified to allow for correction at highest A.
; for TANH: a1 = -1/3 ; a(n)= -1/(4n-3))^2 /(4n-5)/(4n-1)
;   b(n)= 1/(4n-3) /(4n+1)
; Coeffs & U rescaled to make a1=1; Coefs stored in opposite order.
; Order of convergent and starting coeff. found from size of A^2.
FCFTAN LDXIM TANCON ;for TAN(H)
 DEC FACCX
 BRA .+4
FCFATN LDXIM ATNCON ;for ATAN(H)
 PHP
 JSR FSQURS
 PLP
 ROR FACCS ;+ or - X^2
 TXA
 JSR FSZTST
 DEA
 DEA
 STA FRDDDP ;no. of iterations
 TXA
 INY
 CLC
 ADCIM 10
 DEY
 BPL .-3
 ADCIM &F1
 STA COEFP ;starting address of coeffs. -5
 LDAIM F3P0 ;+-3/X^2
 JSR FRECIP+2
 JSR STARGC
 BRA FCFC1
FCFC JSR FCFSTP
 JSR FXDIV
 LDAIM FWSC
 JSR ARGCOM
 JSR FADD
FCFC1 JSR FCFSTP
 JSR FADD
 INC FRDDDP
 BMI FCFC
 JSR ARGA
 JSR FXDIV
 JMP FADD

ASN JSR FLTFAC
 LDA FACCS
 PHA
 JSR FSQURS ;stores in FWSA & squares
 JSR FXDEC
 LDA FACCMA
 BEQ FATAND-3 ;-0+PI/2=PI/2
 JSR FSQRT
 JSR FXDIV ;pointer still set to FWSA
 BRA FATAN+3
;   FATAN COMPUTES  Z= ARCTANGENT. METHOD:
;   (A) ATAN(-X) = -Z
;   (B) IF X>SQR (2)-1 USE Z =PI/4 - ATAN((1-X)/(1+X))
;   (B2) IF X>SQR(2)+1 USE Z = PI/2 -ATAN(1/X)
;   (C) COMPUTE CONT.FRACT. FOR ATAN(X)
;   (D) (PUT BACK PI/2 AND '-')
ATN JSR FLTFAC
FATAN LDA FACCS
 PHA
 CLR FACCS
 LDAIM FATANC+4
 JSR FSZTST
 PHP
 BNE .+6
 JSR M1BYP1
 SEC 
 BCS FATANB
 JSR FRECIP
FATANB LDA FACCX
 CMPIM &6D
 BCC .+5 ;ATN(X)=X
 JSR FCFATN
 PLP
 BNE FATANG
 INC FACCX
 JSR PISUB
 DEC FACCX
 SEC
FATANG BCS FATAND
 JSR PISUB
FATAND PLA
 JMP FNEGX-2 ;restore sign
SIN JSR TRIG
 BRA COS+5
COS JSR TRIG
 INC FQUAD
 LSR FQUAD
 BCC SINB
 JSR P1BYM1+3 ;(1-t~2)/(1+t^2)
 BRA .+5
SINB JSR XDBYP1 ;2t/(1+t^2)
 LSR FQUAD
 BCS TANZ
SINZ TAY
 RTS
TAN JSR TRIG ;returns with &FF in A
 JSR XDBYP1-2 ;2t/(1-t^2)
 LSR FQUAD
 BCC SINZ
 JSR FRECIP
TANZ JMP FNEG

;   FRANGE subtracts an integral multiple of PI/2  or LN2 from ACC,
;   and sets FQUAD to indicate (mod 4, for TRIG) what the INTEGER was.
;   The multiplication & subtraction are done with an extra byte
;   so that large arguments still give decent accuracy.
FRANGE JSR STARGA ;on exit A=FACCX, Y=4
 LDXIM 0
 DEY
 STXZY FACCMA
 CMPAY SQR-4
 BCC .-6 
 LDA COEFP
 JSR CX ;factor twice as big as required
 LDA FACCS
 STA FWRKS
 JSR FINC1+2
 DEC FACCX ;effectively rounded
 JSR IFIX
 STA FQUAD
 JSR IFLT
 JSR FCFSTP
FMULHP JSR FLDW
 LDYIM 5
 LDAIY ARGP 
 STA FWRKMG ;extra byte for accuracy
 JSR IFMUL ;no TIDY
 JSR ARGA
 JMP FXSUB
RAD JSR FLTFAC
 LDAIM FPID18
 BRA CX
LOG JSR LN
 LDAIM RPLN10
CX LDYIM /RPLN10
 STY ARGP+1;multiply by anything in AY
 STA ARGP
 JMP FMUL
DEG JSR FLTFAC
 LDAIM F180DP
 BRA CX
 ;TRIG calculates t=TAN(X/2) and returns with 2*t in FWSA and
 ;t^2 in FACC, here X is the angle shifted to < PI/4 abs.
TRIG JSR FLTFAC
 LDAIM TRIGCO
 JSR FSZTS3
 BCC FRNGQQ
 BNE .+5 ;no need to shift angle
 JSR FRANGE
 LDAIM &6E
 CMP FACCX
 BCS TRIGB
 JSR FCFTAN
 JSR STARGA
 INC FWSA ; double t
TRIGA JMP FSQURE
TRIGB JSR STARGA ;2t = A
 JMP FCLR ;t^2 too small
FEXPB LDA FACCS
 BMI TRIGB+3 ;RETURN ZERO
 BRK ;OVERFLOW CASE
 = &18
 = "Exp range"
FRNGQQ BRK
 = &17
 = "Accuracy lost"
 BRK
;   FEXP ALGORITHM:
;   (A) If ABS(ARG) > 89.5 (approx) then give under/overflow.
;   (B) Let P=nearest multiple of LN2 to ARG, and F be residue
;   (C) Calculate t=TANH(F/2) by C.Frac. and EXP(F)=(1+t)(/1-t)
;   (D) EXP(P) simply modifies FACCX
;   Note that if P<>0, F is calculated to higher precision; and if ARG>=64
; operations are carried out on ARG/2 and result squared,
; to catch any residual overflow.
EXP JSR FLTFAC
FEXP LDAIM EXPCOF
 JSR FSZTS3
 BCC FEXPB ;out of range
 BNE FEXPD ;small
 LDA FACCX
 INA
 ANDIM 8
 BEQ FEXPD
 DEC FACCX
FEXPD DEA
 PHA ;A=0,-1 or 7
 BEQ FEXPA
 JSR FRANGE
FEXPA LDA FACCX
 CMPIM &6A
 BCS FEXPAB
 JSR FINC1 ;EXP(F)=1+F
 BRA FEXPG
FEXPAB JSR FCFTAN
 JSR P1BYM1
FEXPG CLC
 LDA FACCX
 ADC FQUAD
 STA FACCX
 PLA
 DEA
 BPL TRIGA ;square result
 RTS
FSZTS3 JSR SETCOF-2
 CLR FQUAD
FSZTST PHX ;checks into which of 3 ranges
 TAX ;FACC falls.
 LDYIM 1
 DEX
 LDAAX (HALFPI :AND: &FF00)
 CMP FACCX
 BNE FSZTSA
 LDAAX (HALFPI :AND: &FF00)-2
 CMP FACCMA
FSZTSA BCS .+5
 DEY
 BPL FSZTST+4
 PLX
 TYA ;1,0,or -1 in both Y & A
 RTS
 LNK DBAS09
