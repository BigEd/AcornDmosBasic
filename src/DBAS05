
;                                    FILE 6 support routines, if > DBAS05

CREAFN LDYIM 1
 LDAIY WORK
 TAX
 LDAIM &F6
 CPXIM TPROC
 BEQ CREATF
 LDAIM &F8
 BRA CREATF
;  CREATE takes the same parameters as LOOKUP and adds the
;  data item to the linked list. It is not optimised.
CREATE LDYIM 1
 LDAIY WORK
 ASLA
CREATF LDXIM /VARPTR
CREEND STA WORK+3
 STX WORK+4
 LDAIY WORK+3
 BEQ CRENDG
 TAX
 LDAI WORK+3
 BRA CREEND
CRENDG LDA FSA+1
 STAIY WORK+3
 LDA FSA
 STAI WORK+3 ;put in new link address
 LDAIM 0
 STAIY FSA ;put in new 0 high byte
 INY
 CPY WORK+2 ;check if done the length 1 case
 BEQ CREATX
CREDAT LDAIY WORK
 STAIY FSA
 INY
 CPY WORK+2
 BNE CREDAT
 RTS
;  CREAX updates FSA on the assumption that x-1 bytes are to be used
;  Y contains next address offset, four bytes are zeroed
;  If we run out of ram it resets the list end with the old
;  pointer in work+3
CREAX LDAIM 0 ;another entry point to do x-1 bytes
CREZER STAIY FSA
 INY
 DEX
 BNE CREZER
FSAPY CLC
 TYA
 ADC FSA
 BCC CREATY
 INC FSA+1
CREATY LDY FSA+1
 CPY AESTKP+1
 BCC CREATZ
 BNE CREATD
 CMP AESTKP
 BCC CREATZ
CREATD LDAIM 0 ;unlink the entry
 LDYIM 1
 STAIY WORK+3
 JMP ALLOCR
CREATZ STA FSA
CREATX RTS
CRAELT JSR CREAX
CRAELV JSR AELV
 BNE LVRTS
 BCS LVRTS
 JSR CREATE
 LDXIM 5
 CPX IACCN
 BNE CRAELT
 INX
 BRA CRAELT
LVFD CMPIM "!"
 BEQ UNPLIN
 CMPIM "$"
 BEQ DOLL
 EORIM "?"
 BEQ UNIND
 LDAIM 0
 SEC
LVRTS RTS
UNPLIN LDAIM 4
UNIND PHA
 INC AECUR
 JSR INTFAC
 JMP INSET
DOLL INC AECUR
 JSR INTFAC
 LDA IACCM
 BEQ DOLLER
 LDAIM &80
 STA IACCN
 SEC
 RTS
DOLLER BRK
 = 8
 = "$ range"
 BRK
AELV LDY CURSOR
 DEY
LVBLNK INY
 LDAIY LINE
 CMPIM " "
 BEQ LVBLNK
AELVV LDX LINE
 STX AELINE
 LDX LINE+1
 STX AELINE+1
 STY AECUR

;  LV reads the l value of the current item if possible.

;  If it is a numeric lv then the carry will be clear [ !<factor>
;   ?<factor> <variable>!<factor> <variable>?<factor> <word> <word>%
;   <word>( <word>%( ] and IACCN will be 0 for byte, 4 for integer
;   and 5 for a floating point variable

;  If it is a string lv then the carry will be set [ $<factor>
;   <word>$ <word>$( ] and IACCN will be 128 for $<factor> and >128
;   otherwise.

;  In both these cases IACCL,IACCM will be the address of the data
;   byte(s) {or string control block} and there will be an NEQ status

;  If there is an EQ status then if the carry is set it is silly
;   else if the carry is clear it is not in the list.

LVCONT CMPIM "@"
 BCC LVFD ;probably not an lv but check for unary things
;       this test also removes numeric first characters
 CMPIM &5B
 BCS MULTI
 ASLA
 ASLA
 STA IACCL
 INY
 LDAIY AELINE
 CMPIM "%"
 BNE MULTI
 LDAIM /VARL ;optimised address generation
 STA IACCM
 LDXIM 4
 STX IACCN
 INY
 LDAIY AELINE
 CMPIM "("
 BNE CHKQUE
MULTI LDXIM 5
 STX IACCN
 CLC
 LDY AELINE+1
 LDA AECUR
 TAX
 BNE BKTVNO
 DEA
 ADC AELINE
 BCS BKTVNP
 DEY
 BRA BKTVNP
BKTVNO DEA
 ADC AELINE
 BCC BKTVNP
 INY
BKTVNP STA WORK
 STY WORK+1
 LDYIM 1 ;X contains AECUR
 LDAIY WORK
 CMPIM "A"
 BCS BKTVA
 CMPIM "0"
 BCC BKTVE
 CMPIM "9"+1
 BCS BKTVE
BKTVD INX
 INY
 LDAIY WORK
 CMPIM "A"
 BCS BKTVA
 CMPIM "0"
 BCC BKTVE
 CMPIM "9"+1
 BCC BKTVD
 BRA BKTVE
BKTVA CMPIM "Z"+1
 BCC BKTVD
 CMPIM "_"
 BCC BKTVE
 CMPIM "z"+1
 BCC BKTVD
 ASSERT :MSB: BKTVD = :MSB: .
BKTVE CPYIM 1
 BEQ BKTVFL
 CMPIM "$"
 BEQ LVSTR
 CMPIM "%"
 BNE BKTVF
 DEC IACCN
 INX
 INY
 LDAIY WORK
BKTVF CMPIM "("
 BEQ BKTVAR
 JSR LOOKUP
 BEQ BKTVFC
 STX AECUR
CHKPLI LDY AECUR
 LDAIY AELINE
CHKQUE CMPIM "!"
 BEQ BIPLIN
 EORIM "?"
 BEQ BIQUER
 CLC
 STY AECUR
 LDAIM &FF
 RTS
BKTVFC CLC ;unknown
BKTVFL LDAIM 0 ;syntax
 RTS 
BIPLIN LDAIM 4
BIQUER PHA
 INY
 STY AECUR
 JSR VARIND
 JSR INTEGB
 LDA IACCM
 PHA
 LDA IACCL
 PHA
 JSR INTFAC
 CLC
 PLA
 ADC IACCL
 STA IACCL
 PLA
 ADC IACCM
 STA IACCM
INSET PLA
 STA IACCN
 CLC
 LDAIM &FF
 RTS
BKTVAR JSR ARRAY
 BRA CHKPLI
LVSTR DEC IACCN;temp size of 4
 INX
 INY
 LDAIY WORK
 CMPIM "("
 BEQ LVSTRA
 JSR LOOKUP
 BEQ BKTVFC
 STX AECUR
LVSTRB LDAIM &81
 STA IACCN
 SEC
 RTS
LVSTRA JSR ARRAY
 BRA LVSTRB
UNARRY BRK
 = &0E
 = "Array"
 BRK
ARRAY INX
 INY
 JSR LOOKUP
 BEQ UNARRY
 STX AECUR
 LDA IACCN
 PHA
 LDA IACCL
 PHA
 LDA IACCM
 PHA
 LDAI IACCL
 CMPIM 4
 BCC AQUICK
 JSR FALSE
 LDAIM 1
 STA IACCH
ARLOP JSR PHACC
 JSR ININEX
 CPXIM ","
 BNE UNARRY
 LDXIM WORK+2
 JSR POPX
 LDY WORK+5
 PLA
 STA WORK+1
 PLX
 STX WORK
 PHX
 PHA
 JSR TSTRNG
 STY IACCH
 LDAIY WORK
 STA WORK+8
 INY
 LDAIY WORK
 STA WORK+9
 LDA IACCL
 ADC WORK+2
 STA IACCL
 LDA IACCM
 ADC WORK+3
 STA IACCM
 JSR WMUL
 SEC
 LDAI WORK
 SBC IACCH
 CMPIM 3
 BCS ARLOP
 JSR PHACC
 JSR INTBRA
 PLA
 STA WORK+1
 PLA
 STA WORK
 LDXIM WORK+2
 JSR POPX
 LDY WORK+5
 JSR TSTRNG
 CLC
 LDA WORK+2
 ADC IACCL
 STA IACCL
 LDA WORK+3
 ADC IACCM
 STA IACCM
 BCC ARFOUR
AQUICK JSR INTBRA
 PLA
 STA WORK+1
 PLA
 STA WORK
 LDYIM 1
 JSR TSTRNG
ARFOUR PLA
 STA IACCN
 LSRA ;sorts out 5 from 4
 BCC ARFO
 LDX IACCM
 LDA IACCL
 ASLA
 ROL IACCM
 ASLA
 ROL IACCM
 ADC IACCL
 STA IACCL
 TXA
 ADC IACCM
 STA IACCM
 BRA ARFI
ARFO ASL IACCL
 ROL IACCM
 ASL IACCL
 ROL IACCM
ARFI TYA
 ADC IACCL
 BCC .+5
 INC IACCM
 CLC
 ADC WORK
 STA IACCL
 LDA WORK+1
 ADC IACCM
 STA IACCM
 RTS
TSTRNG LDA IACCN
 ORA IACCH
 BNE SUBSCP
 LDA IACCL
 CMPIY WORK
 INY
 LDA IACCM
 SBCIY WORK
 BCS SUBSCP
 INY
 RTS
SUBSCP BRK
 = &0F
 = "Subscript"
 BRK
;  WORD reads a word for LOOKUP
;  Characters A-Z, 0-9 _-z are allowed in a word.
;  WORD increments X and Y as counter and pointer
WORD LDYIM 1
WORDLP LDAIY WORK
 CMPIM "0"
 BCC WORDDN
 CMPIM "@"
 BCS WORDNA
 CMPIM &3A
 BCS WORDDN
 CPYIM 1
 BEQ WORDDN  ;check no number on first character
WORDNC INX
 INY
 BNE WORDLP
WORDNA CMPIM "_"
 BCS WORDNB
 CMPIM &5B
 BCC WORDNC
WORDDN RTS
WORDNB CMPIM &7B
 BCC WORDNC
 RTS
SPTSTM INC CURSOR
SPTSTN LDY CURSOR ;fetches a 2 byte constant using line
 LDAIY LINE
 CMPIM " "
 BEQ SPTSTM
 CMPIM TCONST
 BNE FDA
SPGETN INY
 LDAIY LINE
 ASLA
 ASLA
 TAX
 ANDIM &C0
 INY
 EORIY LINE
 STA IACCL
 TXA
 ASLA
 ASLA
 INY
 EORIY LINE
 STA IACCM
 INY
 STY CURSOR
 SEC
 RTS
FDA CLC
 RTS
AEEQEX LDA LINE
 STA AELINE
 LDA LINE+1
 STA AELINE+1
 LDA CURSOR
 STA AECUR
EQEXPR LDY AECUR ;=<expression><s d> from aeline
 INC AECUR
 LDAIY AELINE
 CMPIM " "
 BEQ EQEXPR
 CMPIM "="
 BEQ EXPRDN
EQERRO BRK
 = 4
 = "Mistake"
STDED BRK
 = &10
 = "Syntax error"
NOPROC BRK
 = &0D
 = "No ",TPROC
DOBRK BRK
 = &11
 = "Escape"
 BRK
EQEAT JSR AESPAC
 CMPIM "="
 BNE EQERRO
 RTS
EXPRDN JSR EXPR ;<expression><s d> from aeline
FDONE TXA  ;fast done immediately after expr
 LDY AECUR
 BRA DONET
AEDONE LDY AECUR ;<s d> from aeline
 BRA DONE+2
ENDPR TSX
 CPXIM &FC
 BCS NOPROC
 LDA &01FF
 CMPIM TPROC
 BNE NOPROC
DONE LDY CURSOR ;<s d> from line
 DEY
BLINK INY
 LDAIY LINE
 CMPIM " "
 BEQ BLINK
DONET CMPIM ":"
 BEQ CLYADP
 CMPIM &0D
 BEQ CLYADP
 CMPIM TELSE
 BNE STDED
CLYADP CLC
 TYA
 ADC LINE
 STA LINE
 BCC SECUR
 INC LINE+1
SECUR LDYIM 1
 STY CURSOR
TSTBRK BIT &FF
 BMI DOBRK
SECEND RTS
FORR JSR DONE ;provides for with the return address
 LDAI LINE
 CMPIM ":"
 BEQ SECEND
 LDA LINE+1
 CMPIM /BUFFER
 BEQ LEAVER
LINO LDYIM 1  ;skip line number
 LDAIY LINE
 BMI LEAVER
 LDX TRFLAG
 BEQ NOTR
 STA IACCM
 INY
 LDAIY LINE
 STA IACCL
 JSR TRJOBA
NOTR LDAIM 3
ADDLIN CLC
 ADC LINE
 STA LINE
 BCC LINOIN
 INC LINE+1
LINOIN LDYIM 1
 STY CURSOR
NOTRDE RTS
LEAVER JMP CLRSTK
;  if statement
IFE JMP LETM
IF JSR AEEXPR
 BEQ IFE
 BPL IFX
 JSR IFIX
IFX LDY AECUR
 STY CURSOR
 LDA IACCL
 ORA IACCM
 ORA IACCN
 ORA IACCH
 BEQ ELSE
 CPXIM TTHEN
 BEQ THEN
THENST JMP STMT
THEN INC CURSOR
THENLN JSR SPTSTN
 BCC THENST
 JSR GOTGO
 JSR SECUR
 JMP GODONE
ELSE LDY CURSOR ;try to find else clause
ELSELP LDAIY LINE
 CMPIM &0D
 BEQ ENDED
 INY
 CMPIM TELSE
 BNE ELSELP
 STY CURSOR
 BEQ THENLN
ENDED JMP ELSELN
TRJOBA LDA IACCL
 CMP TRNUM
 LDA IACCM
 SBC TRNUM+1
 BCS NOTRDE
 LDAIM "["
 JSR CHOUT+4
 JSR POSITE
 LDAIM "]"
 JSR CHOUT+4
 JMP LISTPT
 LNK DBAS06
